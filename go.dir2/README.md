
### 1/
```go
func printNumbers() {
	for i := 1; i <= 5; i++ {
		time.Sleep(500 * time.Millisecond)
		fmt.Printf("%d ", i)
	}
}

func printLetters() {
	for i := 'a'; i < 'e'; i++ {
		time.Sleep(300 * time.Millisecond)
		fmt.Printf("%c ", i)
	}
}
func main() {
	go printNumbers()
	go printLetters()

	time.Sleep(3 * time.Second)
}
```
>Этот код на Go демонстрирует использование горутин `(goroutines)`, которые являются легковесными потоками управляемыми средой выполнения Go.
Функция `printNumbers` **выводит числа от 1 до 5 с задержкой в 500 миллисекунд между числами**.
Функция `printLetters` **выводит буквы от 'a' до 'e' с задержкой в 300 миллисекунд между буквами**.
В функции `main` вызываются `go printNumbers()` и `go printLetters()`. Ключевое слово go перед вызовом функции создает новую горутину, что позволяет этим функциям выполняться параллельно.
time.Sleep(3 * time.Second) используется для приостановки основной горутины на 3 секунды, позволяя другим горутинам завершиться до завершения программы.
При запуске программы вы увидите, как сначала выводятся числа, а затем буквы с задержками между ними. Это демонстрирует параллельное выполнение горутин.


### 2/ 

```go
func main() {
	ch := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			ch <- i
		}
		close(ch)
	}()

	for num := range ch {
		fmt.Println(num)
	}
}
```

> Этот код на Go создает канал `(channel)` ch, который используется для коммуникации между горутинами.
Анонимная функция, запущенная в отдельной горутине с помощью` go func() {...}()`, добавляет числа от 0 до 9 в канал ch с помощью оператора <-. После этого она закрывает канал с помощью `close(ch)`.
В основной функции main **происходит чтение из канала с помощью оператора range**. Когда канал закрывается, цикл завершается, и программа выводит числа, которые были отправлены в канал, одно за другим с помощью `fmt.Println(num)`.
Таким образом, при выполнении программы мы увидим вывод чисел от 0 до 9 в порядке, в котором они были отправлены в канал. Этот пример демонстрирует использование каналов для синхронизации и обмена данными между горутинами в Go.


### 3/

```go

func main() {

	runtime.GOMAXPROCS(2)

	var wg sync.WaitGroup

	wg.Add(2)

	ch := make(chan int)

	for i := 0; i < 2; i++ {
		go func() {
			defer wg.Done()
			for i := 0; i < 10; i++ {
				ch <- i
			}
		}()
	}

	for i := 0; i < 2; i++ {
		go func() {
			defer wg.Done()
			for i := 0; i < 10; i++ {
				fmt.Println(<-ch)
			}
		}()
	}

	wg.Wait()
}

```

>Этот код на Go использует горутины и каналы для синхронизации выполнения.
* `runtime.GOMAXPROCS(2)` устанавливает количество процессоров, которые могут быть использованы для выполнения горутин.
* `var wg sync.WaitGroup` создает `WaitGroup`, который используется для дожидания завершения горутин.
* `wg.Add(2)` указывает, что в группе есть две горутины, которые нужно дождаться.
* `ch := make(chan int)` создает канал для обмена данными между горутинами.
> Затем запускаются две группы горутин: первая группа отправляет числа в канал ch, вторая группа читает числа из канала ch.
`wg.Wait()` ожидает завершения всех горутин.
При выполнении программы мы увидим, что числа от 0 до 9 будут выводиться в произвольном порядке, так как две группы горутин работают параллельно. Этот пример демонстрирует использование WaitGroup для синхронизации горутин и использование каналов для обмена данными между горутинами.


### 4/

```go

type Counter struct {
	mu    sync.Mutex
	count int
}

func (c *Counter) Increment() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.count++
}

func (c *Counter) Decrement() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.count--
}

func (c *Counter) GetValue() int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.count
}

func main() {
	counter := Counter{}

	var wg sync.WaitGroup
	wg.Add(100)

	for i := 0; i < 100; i++ {
		go func() {
			defer wg.Done()
			counter.Increment()
		}()
	}

	wg.Wait()

	fmt.Println("итог:", counter.GetValue())
}

```


> Этот код на Go демонстрирует использование мьютексов для безопасной работы с общими данными из нескольких горутин.
* `type Counter struct` определяет структуру Counter с полем mu типа sync.Mutex для защиты доступа к count - целочисленной переменной.
* Методы `Increment`, `Decrement`, и `GetValue` используют мьютекс для блокировки и разблокировки доступа к count, чтобы избежать гонок данных.
* В функции main создается экземпляр Counter, и запускается 100 горутин, каждая из которых вызывает метод Increment для увеличения count.
* `wg.Wait()` ожидает завершения всех горутин.
> После завершения всех горутин выводится текущее значение count.
При выполнении программы мы увидим, что итоговое значение count будет 100, так как 100 горутин увеличили его на 1 каждая. Этот пример демонстрирует использование мьютексов для обеспечения безопасного доступа к общим данным из нескольких горутин.

### 5/ 
```go
func fetchData(url string, wg *sync.WaitGroup) {
	defer wg.Done()

	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Ошибка при выполнении запроса к %s: %v\n", url, err)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Ошибка при чтении ответа от %s: %v\n", url, err)
		return
	}

	fmt.Printf("Данные для %s: %s\n", url, string(body))
}

func main() {
	var wg sync.WaitGroup

	for i := 0; i <= 10; i++ {
		wg.Add(2)
		go fetchData(fmt.Sprintf("https://jsonplaceholder.typicode.com/posts/%d", i), &wg)
		go fetchData(fmt.Sprintf("https://jsonplaceholder.typicode.com/comments/%d", i), &wg)
	}

	wg.Wait()
}

```
> Функция `fetchData` принимает `URL` для HTTP-запроса и указатель на `sync.WaitGroup`, чтобы отслеживать завершение выполнения. В этой функции:
* Мы используем `http.Get` для выполнения GET-запроса к указанному `URL`.
* Если запрос завершается с ошибкой, мы печатаем сообщение об ошибке и возвращаемся.
* Затем мы закрываем тело ответа с помощью `resp.Body.Close()`, чтобы избежать утечки ресурсов.
* Мы используем `io.ReadAll` для чтения тела ответа.
* Если чтение тела ответа завершается с ошибкой, мы печатаем сообщение об ошибке и возвращаемся.
* Наконец, мы печатаем данные для указанного URL.
>Функция `main` инициализирует `sync.WaitGroup` и запускает цикл для выполнения нескольких запросов. Для каждого запроса создается новая горутина с использованием функции `fetchData`, и после этого увеличивается счетчик `sync.WaitGroup` на 2. После завершения цикла, wg.Wait() блокирует выполнение до тех пор, пока все горутины не завершат свою работу.
Этот код эффективно выполняет параллельные HTTP-запросы к различным URL-адресам и ожидает завершения всех запросов перед завершением программы.




### 6/ 

```go
var (
	counter1 int
	counter2 int
	mutex    sync.RWMutex
	wg       sync.WaitGroup
)

func Inc1() {
	defer wg.Done()
	for i := 0; i < 100; i++ {
		mutex.Lock()
		counter1++
		fmt.Printf("Inc1 counter: %d\n", counter1)
		mutex.Unlock()
		time.Sleep(100 * time.Millisecond)
	}
}

func Inc2() {
	defer wg.Done()
	for i := 0; i < 100; i++ {
		mutex.Lock()
		counter2++
		mutex.Unlock()
		time.Sleep(100 * time.Millisecond)
	}
	mutex.RLock()
	fmt.Printf("Inc2 counter: %d\n", counter2)
	mutex.RUnlock()
}

func main() {
	wg.Add(2)
	go Inc1()
	go Inc2()

	wg.Wait()
}


```

>Этот код содержит три функции и основную функцию main.
Функция `Inc1` и `Inc2` являются горутинами, которые увеличивают значения переменных `counter1` и `counter2` соответственно. 
Они используют мьютекс mutex для обеспечения безопасной одновременной работы с этими переменными. 
Функия `Inc1` увеличивает `counter1` и выводит результат своей работы в консоль в реальном времени, в то время как `Inc2` асинхронно увеличивает свой `counter2` но чтение/изменение `counter2` будет доступно только после того, как `Inc1` полностью завершит свою работу.
Функция `main` запускает эти горутины с помощью `go Inc1()` и `go Inc2()`. Затем она вызывает `wg.Wait()`, чтобы ожидать завершения всех горутин.
В целом, этот код демонстрирует использование мьютексов для обеспечения безопасной одновременной работы с общими переменными в многопоточной среде. Горутины `Inc1` и `Inc2` увеличивают значения переменных `counter1` и `counter2` соответственно, а затем печатают текущие значения.

















